package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

const (
	gotntImport     = "github.com/lomik/go-tnt"
	tarantoolImport = "github.com/narqo/tarantool15"
)

const fileSuffix = "_tnt15"

var (
	typeName = flag.String("type", "", "comma-separated list of type names; must be set")
	output   = flag.String("out", "", "output file name; default srcdir/<src>_tnt15.go")

	debugParser = flag.Bool("debug_parser", false, "print debug output")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("tntgen: ")
	log.SetOutput(os.Stderr)

	flag.Parse()

	if *typeName == "" {
		flag.Usage()
		os.Exit(2)
	}

	args := flag.Args()
	if len(args) == 0 {
		gofile := os.Getenv("GOFILE")
		if gofile != "" {
			args = []string{gofile}
		} else {
			args = []string{"."}
		}
	}

	var (
		dir string
		g   Generator
	)
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
		g.parsePackageDir(args[0])
	} else {
		dir = filepath.Dir(args[0])
		g.parsePackageFiles(args)
	}

	// Print the header and package clause.
	g.Printf("// Code generated by \"pkg/tarantool.v15/tntgen %s\"; DO NOT EDIT.", strings.Join(os.Args[1:], " "))
	g.Printf("")
	g.Printf("package %s", g.pkg.name)
	g.Printf("")
	g.Printf("import \"time\"")
	g.Printf("import \"%s\"", gotntImport)
	g.Printf("import \"%s\"", tarantoolImport)
	g.Printf("")
	g.Printf("var _ = time.Now")

	tt := strings.Split(*typeName, ",")
	for _, typeName := range tt {
		g.generate(typeName)
	}

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "-" {
		fmt.Fprintln(os.Stdin, string(src))
		return
	} else if outputName == "" {
		var baseName string
		if len(g.pkg.files) == 1 {
			baseName = strings.TrimSuffix(g.pkg.files[0].name, ".go")
			baseName = fmt.Sprintf("%s%s.go", baseName, fileSuffix)
		} else {
			baseName = fmt.Sprintf("%s%s.go", g.pkg.name, fileSuffix)
		}
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

type File struct {
	name string
	pkg  *Package
	file *ast.File
}

type Package struct {
	name     string
	dir      string
	files    []*File
	typesPkg *types.Package
}

// check type-checks the package. The package must be OK to proceed.
func (pkg *Package) check(fs *token.FileSet, astFiles []*ast.File) {
	defs := make(map[*ast.Ident]types.Object)
	config := types.Config{Importer: defaultImporter(), FakeImportC: true}
	info := &types.Info{
		Defs: defs,
	}
	typesPkg, err := config.Check(pkg.dir, fs, astFiles, info)
	if err != nil {
		log.Fatalf("checking package: %s", err)
	}
	pkg.typesPkg = typesPkg
}

func defaultImporter() types.Importer {
	return importer.For("source", nil)
}

type Generator struct {
	buf   bytes.Buffer
	pkg   *Package
	debug bool
}

func (g *Generator) debugf(format string, args ...interface{}) {
	if !*debugParser {
		return
	}
	log.Println(fmt.Sprintf(format, args...))
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, strings.TrimSpace(format)+"\n", args...)
}

// parsePackageDir parses the package residing in the directory.
func (g *Generator) parsePackageDir(directory string) {
	pkg, err := build.Default.ImportDir(directory, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", directory, err)
	}
	var names []string
	names = append(names, pkg.GoFiles...)
	names = prefixDirectory(directory, names)
	g.parsePackage(directory, names, nil)
}

func (g *Generator) parsePackageFiles(names []string) {
	g.parsePackage(".", names, nil)
}

func (g *Generator) parsePackage(directory string, names []string, text interface{}) {
	var files []*File

	var astFiles []*ast.File
	g.pkg = new(Package)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, text, 0)
		if err != nil {
			log.Fatalf("parsing package: %s: %s", name, err)
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &File{
			name: name,
			file: parsedFile,
			pkg:  g.pkg,
		})
	}
	if len(astFiles) == 0 {
		log.Fatalf("%s: no buildable Go files", directory)
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.files = files
	g.pkg.dir = directory

	// Type check the package.
	g.pkg.check(fs, astFiles)
}

func prefixDirectory(directory string, names []string) []string {
	if directory == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(directory, name)
	}
	return ret
}

func (g *Generator) generate(typeName string) {
	g.processPackage(typeName)
}

func (g *Generator) processPackage(typeName string) {
	g.debugf("Package: %s", g.pkg.name)

	s := g.pkg.typesPkg.Scope()
	for _, name := range s.Names() {
		obj := s.Lookup(name)
		switch t := obj.Type().(type) {
		case *types.Named:
			if strt, ok := t.Underlying().(*types.Struct); ok {
				g.debugf("Struct: %s", name)
				if name != typeName {
					continue
				}
				g.processStruct(name, strt, t)
			}
		}
	}
}

type Field struct {
	name string
	id   int
	v    *types.Var
}

func (g *Generator) processStruct(typeName string, s *types.Struct, t *types.Named) {
	var fields []Field

	for i := 0; i < s.NumFields(); i++ {
		f := s.Field(i)
		if !f.Exported() || isIgnoredField(s, i) {
			continue
		}

		g.debugf("Field: %s %s", f.Name(), f.Type())
		v := Field{
			name: f.Name(),
			id:   i,
			v:    f,
		}
		fields = append(fields, v)
	}

	g.Printf("")
	g.declareTupleFields(typeName, fields)
	g.Printf("")
	g.declareTuplePackerTo(typeName, fields)
	g.Printf("")
	g.declareTuplePacker(typeName, fields)
}

func isIgnoredField(s *types.Struct, i int) bool {
	return false
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) declareTupleFields(typeName string, fields []Field) {
	g.Printf("const (")
	for _, f := range fields {
		g.Printf("	%sField%s = %d", golangify(typeName), golangify(f.name), f.id)
	}
	g.Printf(")")
}

func (g *Generator) declareTuplePackerTo(typeName string, fields []Field) {
	g.Printf("var _ tarantool.PackerTo = (*%[1]s)(nil)", typeName)
	g.Printf("")
	g.Printf("func (v %[1]s) PackTo(data []byte) []byte {", typeName)
	g.Printf("data = tarantool.PackUint32(data, %[1]d) // count fields", len(fields))
	for i, f := range fields {
		g.buildTupleFieldPackerTo(typeName, i, f)
	}
	g.Printf("return data")
	g.Printf("}")
}

func (g *Generator) buildTupleFieldPackerTo(typeName string, idx int, f Field) {
	switch typ := f.v.Type().(type) {
	case *types.Basic:
		switch typ.Kind() {
		case types.Uint, types.Uint8, types.Uint16, types.Uint32:
			g.Printf("data = tarantool.PackTupleFieldUint32(data, uint32(v.%[1]s))", f.name)
		case types.Uint64:
			g.Printf("data = tarantool.PackTupleFieldUint64(data, uint64(v.%[1]s))", f.name)
		case types.Int, types.Int8, types.Int16, types.Int32:
			g.Printf("data = tarantool.PackTupleFieldUint32(data, uint32(v.%[1]s))", f.name)
		case types.Int64:
			g.Printf("data = tarantool.PackTupleFieldUint64(data, uint64(v.%[1]s))", f.name)
		case types.String:
			g.Printf("data = tarantool.PackTupleFieldString(data, v.%[1]s)", f.name)
		}
	case *types.Slice:
		elem, ok := typ.Elem().(*types.Basic)
		if ok && elem.Kind() == types.Byte {
			g.Printf("data = tarantool.PackTupleFieldBytes(data, v.%[1]s)", f.name)
		} else {
			log.Printf("unsupported type for field %d %s", f.id, f.name)
			return
		}
	case *types.Named:
		switch typ.String() {
		case "time.Time":
			g.Printf("if !v.%[1]s.IsZero() {", f.name)
			g.Printf("	data = tarantool.PackTupleFieldUint32(data, uint32(v.%[1]s.Unix()))", f.name)
			g.Printf("} else {")
			g.Printf("	data = tarantool.PackTupleFieldUint32(data, 0)")
			g.Printf("}")
		case "url.URL":
			g.Printf("data = tarantool.PackTupleFieldString(data, v.%[1]s.String())", f.name)
		default:
			log.Printf("unsupported type for field %d %s", f.id, f.name)
			return
		}
	}
}

func (g *Generator) declareTuplePacker(typeName string, fields []Field) {
	g.Printf("func (v *%s) PackTuple() tnt.Tuple {", typeName)
	g.Printf("	var idx [%d]int", len(fields))
	g.Printf("	data := make([]byte, 0, 256)")
	for i, f := range fields {
		g.buildTupleFieldPacker(typeName, i, f)
	}
	g.Printf("")
	g.Printf("	ret := make(tnt.Tuple, %d)", len(fields))
	g.Printf("	var left int")
	g.Printf("	for i, n := range idx {")
	g.Printf("		if n == 0 { continue }")
	g.Printf("		ret[i] = data[left : left+n]")
	g.Printf("		left += n")
	g.Printf("	}")
	g.Printf("	return ret")
	g.Printf("}")
	g.Printf("")
	g.Printf("func (v *%s) UnpackTuple(tuple tnt.Tuple) (err error) {", typeName)
	g.Printf("	var data []byte")
	g.Printf("	for fid := 0; fid < len(tuple); fid++ {")
	g.Printf("		data = tuple[fid]")
	g.Printf("		switch fid {")
	for _, f := range fields {
		g.Printf("		case %d:", f.id)
		g.buildTupleFieldUnpacker(typeName, f)
	}
	g.Printf("		}")
	g.Printf("	}")
	g.Printf("	return")
	g.Printf("}")
}

func (g *Generator) buildTupleFieldPacker(typeName string, idx int, f Field) {
	var sizeOfField string
	switch typ := f.v.Type().(type) {
	case *types.Basic:
		switch typ.Kind() {
		case types.Uint8:
			g.Printf("data = tarantool.Pack%[1]s(data, v.%[2]s)", golangify(typ.Name()), f.name)
			sizeOfField = "1"
		case types.Uint, types.Uint32:
			g.Printf("data = tarantool.Pack%[1]s(data, v.%[2]s)", golangify(typ.Name()), f.name)
			sizeOfField = "4"
		case types.Uint64:
			g.Printf("data = tarantool.Pack%[1]s(data, v.%[2]s)", golangify(typ.Name()), f.name)
			sizeOfField = "8"
		case types.Int8:
			g.Printf("data = tarantool.PackUint8(data, uint8(v.%[1]s))", f.name)
			sizeOfField = "1"
		case types.Int, types.Int32:
			g.Printf("data = tarantool.PackUint32(data, int32(v.%[1]s))", f.name)
			sizeOfField = "4"
		case types.Int64:
			g.Printf("data = tarantool.PackUint64(data, uint64(v.%[1]s))", f.name)
			sizeOfField = "8"
		case types.String:
			g.Printf("data = tarantool.PackString(data, v.%[1]s)", f.name)
			sizeOfField = fmt.Sprintf("len(v.%[1]s)", f.name)
		}
	case *types.Slice:
		elem, ok := typ.Elem().(*types.Basic)
		if ok && elem.Kind() == types.Byte {
			g.Printf("data = tarantool.PackRawBytes(data, v.%[1]s)", f.name)
			sizeOfField = fmt.Sprintf("len(v.%[1]s)", f.name)
		} else {
			log.Printf("unsupported type for field %d %s", f.id, f.name)
			return
		}
	case *types.Named:
		switch typ.String() {
		case "time.Time":
			g.Printf(stringPackTime, f.name)
			sizeOfField = "4"
		case "url.URL":
			g.Printf("data = tarantool.PackString(data, v.%[1]s.String())", f.name)
			sizeOfField = fmt.Sprintf("len(v.%[1]s.String())", f.name)
		default:
			log.Printf("unsupported type for field %d %s", f.id, f.name)
			return
		}
	}
	g.Printf("idx[%d] = %s", f.id, sizeOfField)
}

var stringPackTime = `
if !v.%[1]s.IsZero() {
	data = tarantool.PackUint32(data, uint32(v.%[1]s.Unix()))
}`

func (g *Generator) buildTupleFieldUnpacker(typeName string, f Field) {
	switch typ := f.v.Type().(type) {
	case *types.Basic:
		switch typ.Kind() {
		case types.Int, types.Int8, types.Int16, types.Int32, types.Int64, types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64:
			g.Printf(stringUnpackUint, f.name, typ.Name())
		case types.String:
			g.Printf(stringUnpackString, f.name)
		}
	case *types.Slice:
		elem, ok := typ.Elem().(*types.Basic)
		if ok && elem.Kind() == types.Byte {
			g.Printf("	v.%s = data", f.name)
		} else {
			log.Printf("unsupported type for field %d %s", f.id, f.name)
			return
		}
	case *types.Named:
		switch typ.String() {
		case "time.Time":
			g.Printf(stringUnpackTime, f.name)
		case "url.URL":
			g.Printf(stringUnpackURL, f.name)
		default:
			log.Printf("unsupported type for field %d %s", f.id, f.name)
			return
		}
	}
}

var stringUnpackUint = `
var v1 uint64
v1, err = tarantool.UnpackUint(data)
if err != nil {
	return err
}
v.%[1]s = %[2]s(v1)`

var stringUnpackString = `
v.%[1]s, err = tarantool.UnpackString(data)
if err != nil {
	return err
}`

var stringUnpackTime = `
var v1 uint64
v1, err = tarantool.UnpackUint(data)
if err != nil {
	return err
}
if v1 != 0 {
	v.%[1]s = time.Unix(int64(v1), 0)
}`

var stringUnpackURL = `
var v1 string
v1, err = tarantool.UnpackString(data)
if err != nil {
	return err
}
v.%[1]s, err = url.Parse(v1)
if err != nil {
	return err
}`

func golangify(name string) (ret string) {
	for i, c := range name {
		if i == 0 {
			ret += string(unicode.ToUpper(c))
		} else {
			ret += string(c)
		}
	}
	return
}
